
See the top level README for information on where to find documentation
for the raspberry pi and the ARM processor inside.  Also find information
on how to load and run these programs.

This is an LED blinker example for the pi3.

The pi3 does have an led, but I am not going to use it (maybe in the
future).  Going to send characters out the uart, so you will need
a uart solution for your host/development machine sooner than normal.

The purpose of the blinker examples is twofold, first because
gpio output state changes tend to be easier to get working than a
uart.  You need to understand the clock feeding the peripherals to
know how to configure the baud rate.  Sometimes they make it crystal
clear sometimes it starts off with a bit of a guess and sometimes
there are hidden divisors (as well as visible ones you didnt know
were there until you knew to look for them).  So as a general approach
of working the problem from both ends reading and experiments the
led blinking routines make a lot of sense.  And you are more likely
to have success without a lot of external tools like jtag or scopes
to get an led blinking than a uart working (took me two hours on my
first pi to get the uart up for various reasons including buggy
documentation, and lack of a scope at home).  There is no led tied to
a gpio on the pi3, so it is a bigger project to talk to the device
that controls the led or use a mailbox interface to the GPU (well
documented these days).  So normally I have boards or loose leds that
I can connect to a gpio pin, but maybe you have not built up your
baremetal toolbox.  So since I have working uart code from prior
raspi experience I am going to start by putting the cart before the
horse and using the already figured out uart, to do blinker stuff which
I normally do to figure out clocks to get to the uart.  Second reason
for the blinkers is to figure out internal timers, sometimes you can
do that without a uart, if you cant then you wait for the uart and
figure out those timers then.

Lastly these blinker examples are pretty much clones of ones done on
the pi-zero and other raspberry pis.  They have similar educational
value but at the same time if you have both types, for now while the
pi-zero is available (and the pi3 for that matter) this repository
wants to focus on the ARM core differences not so much the peripherals.
The ARMv7 and ARMv8 (the latter in the pi3) are significantly more
complicated than the ARMv6 we find in the pi-zero.  I have enough
different chip details from many vendors plus my day job to deal with
and dont have a lot of room for the large amount of information required
for the ARMv7 or ARMv8 nuances.  But I will explore some of them.

This portion of or perhaps the whole repo is 64 bit based.  The 64 bit
ARM instruction set is NOT 64 bit instructions, the instructions are
32 bit but the machine code is completely different than the prior
ARM instruction sets.  The assembly language might be similar but
64 comes from 64 bit registers and most likely a larger address space
(than 32 bits), I have not looked yet at the details have some
questions about it already with the instructions I have examined.  So
these examples also provide a framework if you choose to dabble in
assembly language.  The assembly language you need (some is always
required) has been done for you.  Although remember these examples
are not meant to be libraries or necessarily even a skeleton to work
from, they are educational so you can get past the many failure points
at starting up a processor and peripherals so that you can create your
own style and skeleton.

----


Being the first example I will spend a little more time describing it.
I have some other ramblings on baremetal and the gnu tools so I will
try not to duplicate that.

The primary use case for the raspberry pi is to run some version of
linux.  The three main files to do that are bootloader.bin, start.elf
and kernel8.img.  The first two being GPU programs the last being ARM.
If you have no other files (dont have a config.txt) they (starg.elf
GPU code) copy the kernel8.img file to 0x80000 in RAM, place some
code at address 0x0000 that is intended to prepare the ARM for booting
linux, then branch to 0x80000.  At this time the processor is booted
in aarch32 mode, the backwards compatible ARM instruction set.  These
examples are 64 bit (not 64 bit instructions but a different instruction
set that uses the 64 bit registers, the instructions are still 32 bit
but a completely different machine code than before).  Right now
we need a config.txt file to boot aarch64 and likewise to boot from
address 0x0000, so these aarch64 examples will require both the
config.txt and the kernel8.img file (or use my bootloader with the
notmain.srec file).  If you use this sd card on other raspberry pis
then remember to remove the config.txt file as needed.


vectors.s is the entry point for this program, even an application on
an operating system like linux has some assembly up front before
calling the main function.  For this processor the minimum is to to
set up the stack pointer and call the main function.  Because some
compilers add extra stuff if they see a main() funtion I use some
function name other than main() typically for embedded systems like this.
I have adopted the habit of using notmain() both to not be named main()
and to emphasize this is bare metal and not your average application.

See my ramblings on .data and .bss, I dont need/use them so the
bootstrap (little bit of assembly before calling the first C function)
does not have to prepare those segments.  I only need to setup the
stack and call the first C function in the project.

I normally would set the stack pointer at the top of ram...Well that is
a lie, normaly one would do such a thing, but with code like this that
mostly ports across a number of boards, it becomes a pain keeping track
of who has how much ram.  Instead for simple examples I set the stack
somewhere where it doesnt collide with the code, but also I dont have to
change every board.  Since the application is being loaded at address
0x00000000 I am putting the stack far enough away to not interfere but
still short of all the memory available at 0x08000000 128K.

This example for now drives the uart not an LED, so blinking is a matter
of printing out a character per time period.  This first example is
as simple as it gets but still has some knowledge required.  It
uses the time it takes to execute instructions to kill time between
what was normally state changes in the LED but now a character going
out.

If you were to use this line of code:

for(ra=0;ra<0x1000;ra++) continue;

The optimizer will replace that with this one assignment:

ra = 0x1000;

And actually since that value isnt used again, it is dead code the
optimizer will likely remove that as well.

One way to get around this is to make the loop variable volatile, this
tells the compiler every time you use it grab it from and save it back
to its home in ram.  I prefer a different approach.  I have a simple
dummy function in assembly language, it simply returns.

.globl dummy
dummy:
    ret

The assembly is outside the visibility of the optimizer as would
anything basically not in the same file (llvm is a little different it
might "see" those other objects and optimize across them, gnu wont).

So by having that external function and by passing the loop variable
to it.

for(ra=0;ra<0x1000;ra++) dummy(ra);

We force the compiler to actually implement this code and run that loop
that many times.  Dont need to declare the variable volatile.  If
uncomfortable with assembly langauge you could create a dummy function
in a separately compiled file

void dummy ( void )
{
}

Which produces the same code.

00000000 <dummy>:
   0:   d65f03c0    bx  lr

Some toolchains have the ability to see across objects when they
optimize so you still have to be careful. But optimizing into the
assembly language is rare and dangerous so not much of a worry there.
I prefer the assembly approach to defeating the optimizer.

So this program sets up the uart.  Uses the loop to kill some time,
send a characer, kill some time, repeat forever.
The blink rate will be the same for the same program.  But compiler
differences and options can cause one build to be different from
another in the blink rate.  It is not really deterministic, thus the
desire to use timers in the examples that follow.  If you change the
number the loop counts to and re-build with the same tools, you should
see a change in the blink rate.

Note the Broadcom documentation uses addresses 0x7Exxxxxx for the
peripherals. That is we assume the GPU's address space to access those
things.  The ARM window into that is to date either at 0x20xxxxxx or
0x3Fxxxxxx depending on the specific broadcom chip for that board type
the pi3 uses 0x3Fxxxxxx so when you see 0x7Exxxxxx replace that
0x7E with 0x3F.

I normally dont leave the compiled output in the repository, but you
may need it to compare with your results to see why for example mine
works and yours doesnt, so I will leave these here for this example.


